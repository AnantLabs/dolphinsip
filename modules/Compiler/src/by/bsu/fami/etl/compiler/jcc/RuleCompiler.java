/* Generated By:JJTree&JavaCC: Do not edit this line. RuleCompiler.java */
package by.bsu.fami.etl.compiler.jcc;
import java.io.*;
import java.util.*;
import org.apache.log4j.Logger;
import by.bsu.fami.etl.compiler.bean.*;
public class RuleCompiler/*@bgen(jjtree)*/implements RuleCompilerTreeConstants, RuleCompilerConstants {/*@bgen(jjtree)*/
  protected JJTRuleCompilerState jjtree = new JJTRuleCompilerState();private final static Logger LOGGER = Logger.getLogger(RuleCompiler.class );
  // Hastable for storing typedef typesprivate static Set types = new HashSet();
  public static RuleCompiler compile(Reader input){
    LOGGER.info("Create rule compiler for rule source file :"+input);
    RuleCompiler c = new RuleCompiler(input);
    return c;
  }
  // Returns true if the given string is// a typedef type.private static boolean isType(String type){
    return types.contains(type);
  }
  public static void dump(SimpleNode e, String prefix){
    LOGGER.debug(e.toString(prefix)+":"+e.jjtGetValue());
    for (int i = 0;
    i<e.jjtGetNumChildren();
    ++i){
      SimpleNode n = (SimpleNode)e.jjtGetChild(i);
      if (n != null){
        dump(n, prefix+"\u005ct");
      }
    }
  }

  final public SimpleNode Rule() throws ParseException {
                   /*@bgen(jjtree) Rule */
  SimpleNode jjtn000 = new SimpleNode(JJTRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  SimpleNode property;
  SimpleNode component;
  SimpleNode checker;
  SimpleNode dataSource;
  Rule rule = new Rule();
  Function fun;
    try {
      jj_consume_token(RULE);
      t = jj_consume_token(IDENTIFIER);
      jj_consume_token(LBRACE);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROPERTY:
          ;
          break;
        default:
          break label_1;
        }
        property = Property();
    rule.getProperties().add((Property)property.jjtGetValue());
      }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WRITER:
        case READER:
        case TRANSFORMER:
        case FILTER:
        case TRANSACTIONTYPE:
          ;
          break;
        default:
          break label_2;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WRITER:
          component = Writer();
          break;
        case TRANSFORMER:
          component = Transformer();
          break;
        case FILTER:
          component = Filter();
          break;
        case TRANSACTIONTYPE:
          component = TransactonType();
          break;
        case READER:
          component = Reader();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
    rule.getComponents().add((Component)component.jjtGetValue());
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHECKER:
        checker = Checker();
    rule.setChecker((Checker)checker.jjtGetValue());
        break;
      default:
        ;
      }
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DATASOURCE:
          ;
          break;
        default:
          break label_3;
        }
        dataSource = DataSource();
    rule.getDataSources().add((DataSource)dataSource.jjtGetValue());
      }
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FUNCTION:
          ;
          break;
        default:
          break label_4;
        }
        fun = MethodDeclaration();
    rule.getFunctions().add(fun);
      }
      jj_consume_token(RBRACE);
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
    rule.setName(t.image);
    jjtn000.jjtSetValue(rule);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode Property() throws ParseException {
                       /*@bgen(jjtree) Property */
  SimpleNode jjtn000 = new SimpleNode(JJTPROPERTY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token name;
  Token value;
    try {
      jj_consume_token(PROPERTY);
      name = jj_consume_token(IDENTIFIER);
      jj_consume_token(ASSIGN);
      value = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
                                                                            jjtree.closeNodeScope(jjtn000, true);
                                                                            jjtc000 = false;
    Property property = new Property();
    property.setName(name.image);
    property.setValue(value.image.replace("\u005c"", ""));
    jjtn000.jjtSetValue(property);
    {if (true) return jjtn000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode Field() throws ParseException {
                    /*@bgen(jjtree) Field */
  SimpleNode jjtn000 = new SimpleNode(JJTFIELD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token name;
  Token type;
  Token value;
    try {
      jj_consume_token(FIELD);
      name = jj_consume_token(IDENTIFIER);
      jj_consume_token(COLON);
      type = TypeSpecifier();
      jj_consume_token(ASSIGN);
      value = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
                                                                                                      jjtree.closeNodeScope(jjtn000, true);
                                                                                                      jjtc000 = false;
    Field field = new Field();
    field.setName(name.image);
    field.setType(type.image);
    field.setValue(value.image.replace("\u005c"", ""));
    jjtn000.jjtSetValue(field);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode Reader() throws ParseException {
                     /*@bgen(jjtree) Reader */
  SimpleNode jjtn000 = new SimpleNode(JJTREADER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  Token type;
  Token ds;
  Token map;
  Token call;
  Token outputScheme;
  SimpleNode field;
  SimpleNode property;
  DataReader dataReader = new DataReader();
    try {
      jj_consume_token(READER);
      t = jj_consume_token(IDENTIFIER);
      jj_consume_token(LBRACE);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROPERTY:
          ;
          break;
        default:
          break label_5;
        }
        property = Property();
    dataReader.getProperties().add((Property)property.jjtGetValue());
      }
      jj_consume_token(TYPE);
      jj_consume_token(ASSIGN);
      type = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(DS);
      jj_consume_token(ASSIGN);
      ds = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(MAP);
      jj_consume_token(ASSIGN);
      map = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(OUTPUTSCHEME);
      jj_consume_token(ASSIGN);
      outputScheme = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CALL:
          ;
          break;
        default:
          break label_6;
        }
        jj_consume_token(CALL);
        jj_consume_token(ASSIGN);
        call = jj_consume_token(STRING_LITERAL);
        jj_consume_token(SEMICOLON);
    dataReader.getCalleds().add(call.image.replace("\u005c"", ""));
      }
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD:
          ;
          break;
        default:
          break label_7;
        }
        field = Field();
    dataReader.getFields().add((Field)field.jjtGetValue());
      }
      jj_consume_token(RBRACE);
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
    dataReader.setName(t.image);
    dataReader.setType(type.image.replace("\u005c"", ""));
    dataReader.setDataSource(ds.image.replace("\u005c"", ""));
    dataReader.setMap(map.image.replace("\u005c"", ""));
    dataReader.setOutputScheme(outputScheme.image.replace("\u005c"", ""));
    jjtn000.jjtSetValue(dataReader);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode Transformer() throws ParseException {
                          /*@bgen(jjtree) Transformer */
  SimpleNode jjtn000 = new SimpleNode(JJTTRANSFORMER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  Token type;
  Token outputScheme;
  Token call;
  SimpleNode field;
  SimpleNode property;
  Transformer transformer = new Transformer();
    try {
      jj_consume_token(TRANSFORMER);
      t = jj_consume_token(IDENTIFIER);
      jj_consume_token(LBRACE);
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROPERTY:
          ;
          break;
        default:
          break label_8;
        }
        property = Property();
    transformer.getProperties().add((Property)property.jjtGetValue());
      }
      jj_consume_token(TYPE);
      jj_consume_token(ASSIGN);
      type = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(OUTPUTSCHEME);
      jj_consume_token(ASSIGN);
      outputScheme = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CALL:
          ;
          break;
        default:
          break label_9;
        }
        jj_consume_token(CALL);
        jj_consume_token(ASSIGN);
        call = jj_consume_token(STRING_LITERAL);
        jj_consume_token(SEMICOLON);
    transformer.getCalleds().add(call.image.replace("\u005c"", ""));
      }
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD:
          ;
          break;
        default:
          break label_10;
        }
        field = Field();
    transformer.getFields().add((Field)field.jjtGetValue());
      }
      jj_consume_token(RBRACE);
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
    transformer.setName(t.image);
    transformer.setOutputScheme(outputScheme.image.replace("\u005c"", ""));
    transformer.setType(type.image.replace("\u005c"", ""));
    jjtn000.jjtSetValue(transformer);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode Checker() throws ParseException {
                      /*@bgen(jjtree) Checker */
  SimpleNode jjtn000 = new SimpleNode(JJTCHECKER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  Token type;
  Token condition;
  SimpleNode property;
  Checker checker = new Checker();
    try {
      jj_consume_token(CHECKER);
      t = jj_consume_token(IDENTIFIER);
      jj_consume_token(LBRACE);
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROPERTY:
          ;
          break;
        default:
          break label_11;
        }
        property = Property();
    checker.getProperties().add((Property)property.jjtGetValue());
      }
      jj_consume_token(TYPE);
      jj_consume_token(ASSIGN);
      type = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(CONDITION);
      jj_consume_token(ASSIGN);
      condition = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(RBRACE);
                                                                                                                        jjtree.closeNodeScope(jjtn000, true);
                                                                                                                        jjtc000 = false;
    checker.setName(t.image);
    checker.setType(type.image.replace("\u005c"", ""));
    checker.setCondition(condition.image.replace("\u005c"", ""));
    jjtn000.jjtSetValue(checker);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode Filter() throws ParseException {
                     /*@bgen(jjtree) Filter */
  SimpleNode jjtn000 = new SimpleNode(JJTFILTER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  Token type;
  Token outputScheme;
  Token condition;
  Token call;
  SimpleNode field;
  SimpleNode property;
  Filter filter = new Filter();
    try {
      jj_consume_token(FILTER);
      t = jj_consume_token(IDENTIFIER);
      jj_consume_token(LBRACE);
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROPERTY:
          ;
          break;
        default:
          break label_12;
        }
        property = Property();
    filter.getProperties().add((Property)property.jjtGetValue());
      }
      jj_consume_token(TYPE);
      jj_consume_token(ASSIGN);
      type = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(CONDITION);
      jj_consume_token(ASSIGN);
      condition = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(OUTPUTSCHEME);
      jj_consume_token(ASSIGN);
      outputScheme = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CALL:
          ;
          break;
        default:
          break label_13;
        }
        jj_consume_token(CALL);
        jj_consume_token(ASSIGN);
        call = jj_consume_token(STRING_LITERAL);
        jj_consume_token(SEMICOLON);
    filter.getCalleds().add(call.image.replace("\u005c"", ""));
      }
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD:
          ;
          break;
        default:
          break label_14;
        }
        field = Field();
    filter.getFields().add((Field)field.jjtGetValue());
      }
      jj_consume_token(RBRACE);
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
    filter.setName(t.image);
    filter.setOutputScheme(outputScheme.image.replace("\u005c"", ""));
    filter.setType(type.image.replace("\u005c"", ""));
    filter.setCondition(condition.image.replace("\u005c"", ""));
    jjtn000.jjtSetValue(filter);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode TransactonType() throws ParseException {
                             /*@bgen(jjtree) TransactonType */
  SimpleNode jjtn000 = new SimpleNode(JJTTRANSACTONTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  Token type;
  Token outputScheme;
  Token value;
  Token call;
  SimpleNode field;
  SimpleNode property;
  TransactonType transactonType = new TransactonType();
    try {
      jj_consume_token(TRANSACTIONTYPE);
      t = jj_consume_token(IDENTIFIER);
      jj_consume_token(LBRACE);
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROPERTY:
          ;
          break;
        default:
          break label_15;
        }
        property = Property();
    transactonType.getProperties().add((Property)property.jjtGetValue());
      }
      jj_consume_token(TYPE);
      jj_consume_token(ASSIGN);
      type = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(VALUE);
      jj_consume_token(ASSIGN);
      value = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(OUTPUTSCHEME);
      jj_consume_token(ASSIGN);
      outputScheme = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CALL:
          ;
          break;
        default:
          break label_16;
        }
        jj_consume_token(CALL);
        jj_consume_token(ASSIGN);
        call = jj_consume_token(STRING_LITERAL);
        jj_consume_token(SEMICOLON);
    transactonType.getCalleds().add(call.image.replace("\u005c"", ""));
      }
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD:
          ;
          break;
        default:
          break label_17;
        }
        field = Field();
    transactonType.getFields().add((Field)field.jjtGetValue());
      }
      jj_consume_token(RBRACE);
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
    transactonType.setName(t.image);
    transactonType.setOutputScheme(outputScheme.image.replace("\u005c"", ""));
    transactonType.setType(type.image.replace("\u005c"", ""));
    transactonType.setValue(value.image.replace("\u005c"", ""));
    jjtn000.jjtSetValue(transactonType);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode Writer() throws ParseException {
                     /*@bgen(jjtree) Writer */
  SimpleNode jjtn000 = new SimpleNode(JJTWRITER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  Token type;
  Token ds;
  Token rootId;
  Token fieldId;
  Token fieldKeys;
  Token call;
  Token outputScheme;
  SimpleNode field;
  SimpleNode property;
  DataWriter dataWriter = new DataWriter();
    try {
      jj_consume_token(WRITER);
      t = jj_consume_token(IDENTIFIER);
      jj_consume_token(LBRACE);
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROPERTY:
          ;
          break;
        default:
          break label_18;
        }
        property = Property();
    dataWriter.getProperties().add((Property)property.jjtGetValue());
      }
      jj_consume_token(TYPE);
      jj_consume_token(ASSIGN);
      type = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(DS);
      jj_consume_token(ASSIGN);
      ds = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(ROOTID);
      jj_consume_token(ASSIGN);
      rootId = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(FIELDID);
      jj_consume_token(ASSIGN);
      fieldId = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(FIELDKEYS);
      jj_consume_token(ASSIGN);
      fieldKeys = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(OUTPUTSCHEME);
      jj_consume_token(ASSIGN);
      outputScheme = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CALL:
          ;
          break;
        default:
          break label_19;
        }
        jj_consume_token(CALL);
        jj_consume_token(ASSIGN);
        call = jj_consume_token(STRING_LITERAL);
        jj_consume_token(SEMICOLON);
    dataWriter.getCalleds().add(call.image.replace("\u005c"", ""));
      }
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FIELD:
          ;
          break;
        default:
          break label_20;
        }
        field = Field();
    dataWriter.getFields().add((Field)field.jjtGetValue());
      }
      jj_consume_token(RBRACE);
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
    dataWriter.setName(t.image);
    dataWriter.setType(type.image.replace("\u005c"", ""));
    dataWriter.setDataSource(ds.image.replace("\u005c"", ""));
    dataWriter.setOutputScheme(outputScheme.image.replace("\u005c"", ""));
    dataWriter.setRootId(rootId.image.replace("\u005c"", ""));
    dataWriter.setFieldId(fieldId.image.replace("\u005c"", ""));
    dataWriter.setFieldKeys(fieldKeys.image.replace("\u005c"", ""));
    jjtn000.jjtSetValue(dataWriter);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode DataSource() throws ParseException {
                         /*@bgen(jjtree) DataSource */
  SimpleNode jjtn000 = new SimpleNode(JJTDATASOURCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token name;
  Token type;
  SimpleNode property;
  DataSource dataSource = new DataSource();
    try {
      jj_consume_token(DATASOURCE);
      name = jj_consume_token(IDENTIFIER);
      jj_consume_token(LBRACE);
      label_21:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROPERTY:
          ;
          break;
        default:
          break label_21;
        }
        property = Property();
    dataSource.getProperties().add((Property)property.jjtGetValue());
      }
      jj_consume_token(TYPE);
      jj_consume_token(ASSIGN);
      type = jj_consume_token(STRING_LITERAL);
      jj_consume_token(SEMICOLON);
      jj_consume_token(RBRACE);
                                                              jjtree.closeNodeScope(jjtn000, true);
                                                              jjtc000 = false;
    dataSource.setName(name.image);
    dataSource.setType(type.image.replace("\u005c"", ""));
    jjtn000.jjtSetValue(dataSource);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public Token TypeSpecifier() throws ParseException {
                       /*@bgen(jjtree) TypeSpecifier */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPESPECIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VOID:
        t = jj_consume_token(VOID);
        break;
      case CHAR:
        t = jj_consume_token(CHAR);
        break;
      case BOOLEAN:
        t = jj_consume_token(BOOLEAN);
        break;
      case INT:
        t = jj_consume_token(INT);
        break;
      case LONG:
        t = jj_consume_token(LONG);
        break;
      case FLOAT:
        t = jj_consume_token(FLOAT);
        break;
      case DOUBLE:
        t = jj_consume_token(DOUBLE);
        break;
      case SHORT:
        t = jj_consume_token(SHORT);
        break;
      case BYTE:
        t = jj_consume_token(BYTE);
        break;
      default:
        if (isType(getToken(1).image)) {
          t = TypedefName();
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
    {if (true) return t;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public Token TypedefName() throws ParseException {
                     /*@bgen(jjtree) TypedefName */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPEDEFNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(IDENTIFIER);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
    {if (true) return t;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public Token Type() throws ParseException {
              /*@bgen(jjtree) Type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      if (jj_2_1(2)) {
        t = ReferenceType();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOUBLE:
        case SHORT:
        case BYTE:
        case FLOAT:
        case BOOLEAN:
        case LONG:
        case CHAR:
        case INT:
          t = PrimitiveType();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
    jjtn000.jjtSetValue(t.image.replace("\u005c"", ""));
    {if (true) return t;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public Token PrimitiveType() throws ParseException {
                       /*@bgen(jjtree) PrimitiveType */
  SimpleNode jjtn000 = new SimpleNode(JJTPRIMITIVETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
        t = jj_consume_token(BOOLEAN);
        break;
      case CHAR:
        t = jj_consume_token(CHAR);
        break;
      case BYTE:
        t = jj_consume_token(BYTE);
        break;
      case SHORT:
        t = jj_consume_token(SHORT);
        break;
      case INT:
        t = jj_consume_token(INT);
        break;
      case LONG:
        t = jj_consume_token(LONG);
        break;
      case FLOAT:
        t = jj_consume_token(FLOAT);
        break;
      case DOUBLE:
        t = jj_consume_token(DOUBLE);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
    jjtn000.jjtSetValue(t.image.replace("\u005c"", ""));
    {if (true) return t;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public Token ReferenceType() throws ParseException {
                       /*@bgen(jjtree) ReferenceType */
  SimpleNode jjtn000 = new SimpleNode(JJTREFERENCETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOUBLE:
      case SHORT:
      case BYTE:
      case FLOAT:
      case BOOLEAN:
      case LONG:
      case CHAR:
      case INT:
        t = PrimitiveType();
        label_22:
        while (true) {
          jj_consume_token(LBRACKET);
          jj_consume_token(RBRACKET);
          if (jj_2_2(2)) {
            ;
          } else {
            break label_22;
          }
        }
        break;
      case IDENTIFIER:
        t = ClassOrInterfaceType();
        label_23:
        while (true) {
          if (jj_2_3(2)) {
            ;
          } else {
            break label_23;
          }
          jj_consume_token(LBRACKET);
          jj_consume_token(RBRACKET);
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                        jjtree.closeNodeScope(jjtn000, true);
                                                        jjtc000 = false;
    jjtn000.jjtSetValue(t.image.replace("\u005c"", ""));
    {if (true) return t;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public Token ClassOrInterfaceType() throws ParseException {
                              /*@bgen(jjtree) ClassOrInterfaceType */
  SimpleNode jjtn000 = new SimpleNode(JJTCLASSORINTERFACETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(IDENTIFIER);
    jjtn000.jjtSetValue(t.image.replace("\u005c"", ""));
    {if (true) return t;}
      if (jj_2_4(2)) {
        TypeArguments();
      } else {
        ;
      }
      label_24:
      while (true) {
        if (jj_2_5(2)) {
          ;
        } else {
          break label_24;
        }
        jj_consume_token(DOT);
        jj_consume_token(IDENTIFIER);
        if (jj_2_6(2)) {
          TypeArguments();
        } else {
          ;
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void TypeArguments() throws ParseException {
                      /*@bgen(jjtree) TypeArguments */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPEARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LT);
      TypeArgument();
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_25;
        }
        jj_consume_token(COMMA);
        TypeArgument();
      }
      jj_consume_token(100);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void TypeArgument() throws ParseException {
                     /*@bgen(jjtree) TypeArgument */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPEARGUMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOUBLE:
      case SHORT:
      case BYTE:
      case FLOAT:
      case BOOLEAN:
      case LONG:
      case CHAR:
      case INT:
      case IDENTIFIER:
        ReferenceType();
        break;
      case HOOK:
        jj_consume_token(HOOK);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 101:
        case 102:
          WildcardBounds();
          break;
        default:
          ;
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void WildcardBounds() throws ParseException {
                       /*@bgen(jjtree) WildcardBounds */
  SimpleNode jjtn000 = new SimpleNode(JJTWILDCARDBOUNDS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 101:
        jj_consume_token(101);
        ReferenceType();
        break;
      case 102:
        jj_consume_token(102);
        ReferenceType();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void TypeBound() throws ParseException {
                  /*@bgen(jjtree) TypeBound */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPEBOUND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(101);
      ClassOrInterfaceType();
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BIT_AND:
          ;
          break;
        default:
          break label_26;
        }
        jj_consume_token(BIT_AND);
        ClassOrInterfaceType();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//  Method --------------------------------------------------------  final public Function MethodDeclaration() throws ParseException {
                              /*@bgen(jjtree) MethodDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTMETHODDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Function fun = new Function();
  Token block = null;
  Token name;
  Token resultType;
  List<FunctionParameter>params;
    try {
      jj_consume_token(FUNCTION);
      name = jj_consume_token(IDENTIFIER);
    fun.setName(name.image.replace("\u005c"", ""));
      params = FormalParameters();
      jj_consume_token(COLON);
      resultType = ResultType();
    fun.setReturnType(resultType.image.replace("\u005c"", ""));
      jj_consume_token(LBRACE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        block = jj_consume_token(IDENTIFIER);
        break;
      default:
        ;
      }
      jj_consume_token(RBRACE);
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
    if (block != null){
      fun.setBlock(block.image.replace("\u005c"", ""));
    }
    fun.setParametrs(params);
    jjtn000.jjtSetValue(fun);
    {if (true) return fun;}
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
    throw new Error("Missing return statement in function");
  }

  final public List<FunctionParameter> FormalParameters() throws ParseException {
                                           /*@bgen(jjtree) FormalParameters */
  SimpleNode jjtn000 = new SimpleNode(JJTFORMALPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);List<FunctionParameter>params = new ArrayList<FunctionParameter>();
  FunctionParameter param;
    try {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOUBLE:
      case SHORT:
      case BYTE:
      case FLOAT:
      case BOOLEAN:
      case LONG:
      case CHAR:
      case INT:
      case IDENTIFIER:
        param = FormalParameter();
    params.add(param);
        label_27:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            break label_27;
          }
          jj_consume_token(COMMA);
          param = FormalParameter();
    params.add(param);
        }
        break;
      default:
        ;
      }
      jj_consume_token(RPAREN);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
    jjtn000.jjtSetValue(params);
    {if (true) return params;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public FunctionParameter FormalParameter() throws ParseException {
                                     /*@bgen(jjtree) FormalParameter */
  SimpleNode jjtn000 = new SimpleNode(JJTFORMALPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);FunctionParameter param = new FunctionParameter();
  Token name;
  Token type;
    try {
      type = Type();
      name = jj_consume_token(IDENTIFIER);
                                      jjtree.closeNodeScope(jjtn000, true);
                                      jjtc000 = false;
    param.setName(name.image.replace("\u005c"", ""));
    param.setType(type.image.replace("\u005c"", ""));
    jjtn000.jjtSetValue(param);
    {if (true) return param;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public Token ResultType() throws ParseException {
                    /*@bgen(jjtree) ResultType */
  SimpleNode jjtn000 = new SimpleNode(JJTRESULTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VOID:
        t = jj_consume_token(VOID);
        break;
      case DOUBLE:
      case SHORT:
      case BYTE:
      case FLOAT:
      case BOOLEAN:
      case LONG:
      case CHAR:
      case INT:
      case IDENTIFIER:
        t = Type();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
    jjtn000.jjtSetValue(t.image.replace("\u005c"", ""));
    {if (true) return t;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_3R_34() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_4()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_5()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_33() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_31() {
    if (jj_3R_34()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_3()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3R_30() {
    if (jj_3R_33()) return true;
    Token xsp;
    if (jj_3_2()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_2()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_36() {
    if (jj_scan_token(HOOK)) return true;
    return false;
  }

  private boolean jj_3R_28() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    }
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) return true;
    }
    return false;
  }

  private boolean jj_3R_29() {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_29()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public RuleCompilerTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;

  /** Constructor with InputStream. */
  public RuleCompiler(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public RuleCompiler(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new RuleCompilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }

  /** Constructor. */
  public RuleCompiler(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new RuleCompilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }

  /** Constructor with generated Token Manager. */
  public RuleCompiler(RuleCompilerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  public void ReInit(RuleCompilerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      return token;
    }
    token = oldToken;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    Token errortok = token.next;
    int line = errortok.beginLine, column = errortok.beginColumn;
    String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
    return new ParseException("Parse error at line " + line + ", column " + column + ".  Encountered: " + mess);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
